<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>æ¨ç®±å­ğŸ“¦</title>
<style>
body{text-align:center;font-family:Arial}
canvas{border:2px solid #333;background:#fafafa;margin-top:10px;}
button{margin:5px;padding:6px 10px;font-size:16px;}
#controls{margin-top:10px;}
</style>
</head>
<body>
<h2>æ¥æ¨ç®±å­å§</h2>
<div id="controls">
  <button onclick="move('up')">â¬†ï¸</button>
  <button onclick="move('left')">â¬…ï¸</button>
  <button onclick="move('down')">â¬‡ï¸</button>
  <button onclick="move('right')">â¡ï¸</button>
  <button onclick="undo()">â†©ï¸ä¸Šä¸€æ­¥</button>
  <button onclick="resetLevel()">ğŸ”„ é‡ç½®</button>
</div>
<canvas id="game" width="400" height="400"></canvas>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const size=40;
const cols=10, rows=10;

let walls=[], rocks=[], targets=[], boxes=[], player;
let history=[];
let level=1;

// -------------------- ç”Ÿæˆå…³å¡ --------------------
function generateLevel(){
    walls=[]; rocks=[]; targets=[]; boxes=[]; history=[];
    // å¢™
    for(let i=0;i<cols;i++){ walls.push({x:i,y:0}); walls.push({x:i,y:rows-1}); }
    for(let i=0;i<rows;i++){ walls.push({x:0,y:i}); walls.push({x:cols-1,y:i}); }

    // éšæœºéšœç¢
    while(rocks.length<6){
        let x=Math.floor(Math.random()*(cols-2))+1;
        let y=Math.floor(Math.random()*(rows-2))+1;
        if(!isOccupied(x,y)) rocks.push({x,y});
    }

    // éšæœºç›®æ ‡
    while(targets.length<3){
        let x=Math.floor(Math.random()*(cols-2))+1;
        let y=Math.floor(Math.random()*(rows-2))+1;
        if(!isOccupied(x,y)) targets.push({x,y});
    }

    // ç®±å­åˆå§‹æ”¾åœ¨ç›®æ ‡ä¸Šï¼Œæ ‡è®° locked=false
    boxes = targets.map(t=>({x:t.x,y:t.y,locked:false}));

    // åæ¨å¼ç”Ÿæˆ
    for(let i=0;i<30;i++){
        const b = boxes[Math.floor(Math.random()*boxes.length)];
        reverseMoveBox(b);
    }

    // ç©å®¶æ”¾ç©ºåœ°
    do{
        player={x:Math.floor(Math.random()*(cols-2))+1,y:Math.floor(Math.random()*(rows-2))+1};
    }while(isOccupied(player.x,player.y));
}

// åˆ¤æ–­æ ¼å­æ˜¯å¦è¢«å ç”¨
function isOccupied(x,y){
    return walls.some(w=>w.x===x&&w.y===y)
        || rocks.some(r=>r.x===x&&r.y===y)
        || boxes.some(b=>b.x===x&&b.y===y);
}

// åˆ¤æ–­æ ¼å­æ˜¯å¦ä¸ºç©ºï¼ˆå¯ç§»åŠ¨ï¼‰
function isFree(x,y){
    if(x<0||y<0||x>=cols||y>=rows) return false;
    if(walls.some(w=>w.x===x&&w.y===y)) return false;
    if(rocks.some(r=>r.x===x&&r.y===y)) return false;
    if(boxes.some(b=>b.x===x&&b.y===y && !b.locked)) return false;
    return true;
}

// -------------------- åæ¨æ‹‰ç®±å­ --------------------
function reverseMoveBox(box){
    const dirs=[{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}];
    dirs.sort(()=>Math.random()-0.5); // éšæœºé¡ºåº
    for(let d of dirs){
        const fromX = box.x + d.x;
        const fromY = box.y + d.y;
        const pushX = box.x - d.x;
        const pushY = box.y - d.y;
        if(isFree(fromX,fromY) && isFree(pushX,pushY)){
            // æ¨¡æ‹Ÿæœ‰äººä»pushX,pushYç«™ä½æ‹‰ç®±å­åˆ°fromX,fromY
            box.x = fromX;
            box.y = fromY;
            return true;
        }
    }
    return false;
}

// -------------------- ç»˜åˆ¶ --------------------
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.font="32px serif";
    walls.forEach(w=>ctx.fillText('ğŸ§±', w.x*size+2,w.y*size+32));
    rocks.forEach(r=>ctx.fillText('ğŸª¨', r.x*size+2,r.y*size+32));
    targets.forEach(t=>ctx.fillText('âŒ', t.x*size+2,t.y*size+32));
    boxes.forEach(b=>{
        ctx.fillText('ğŸ“¦', b.x*size+2,b.y*size+32);
    });
    ctx.fillText('ğŸ¤—', player.x*size+2,player.y*size+32);
}

// -------------------- ç§»åŠ¨ --------------------
function move(dir){
    const dx=dir==='left'?-1:dir==='right'?1:0;
    const dy=dir==='up'?-1:dir==='down'?1:0;
    const newX=player.x+dx;
    const newY=player.y+dy;

    // å¢™/éšœç¢ç‰©
    if(walls.some(w=>w.x===newX&&w.y===newY) || rocks.some(r=>r.x===newX&&r.y===newY)) return;

    let boxIndex = boxes.findIndex(b=>b.x===newX&&b.y===newY && !b.locked);
    if(boxIndex!==-1){
        let box = boxes[boxIndex];
        let nextX = box.x + dx;
        let nextY = box.y + dy;
        if(isOccupied(nextX,nextY)) return;
        // ä¿å­˜å†å²
        history.push({
            player:{...player},
            boxes:boxes.map(b=>({...b}))
        });
        box.x = nextX;
        box.y = nextY;
        // å¦‚æœåˆ°ç›®æ ‡ï¼Œé”å®š
        if(targets.some(t=>t.x===box.x&&t.y===box.y)){
            box.locked = true;
        }
        player.x = newX;
        player.y = newY;
    }else{
        history.push({
            player:{...player},
            boxes:boxes.map(b=>({...b}))
        });
        player.x = newX;
        player.y = newY;
    }
    draw();
    if(checkWin()) setTimeout(nextLevel,100);
}

// -------------------- ä¸Šä¸€æ­¥ --------------------
function undo(){
    if(history.length===0) return;
    const last = history.pop();
    player={...last.player};
    boxes = last.boxes.map(b=>({...b}));
    draw();
}

// -------------------- é‡ç½®å…³å¡ --------------------
function resetLevel(){
    generateLevel();
    draw();
}

// -------------------- é€šå…³æ£€æµ‹ --------------------
function checkWin(){
    return boxes.every(b => targets.some(t=>t.x===b.x && t.y===b.y));
}

// -------------------- ä¸‹ä¸€å…³ --------------------
function nextLevel(){
    level++;
    alert("é€šå…³ï¼è¿›å…¥ç¬¬"+level+"å…³");
    generateLevel();
    draw();
}

// -------------------- é”®ç›˜æ§åˆ¶ --------------------
document.addEventListener("keydown",e=>{
    if(e.key==='ArrowUp'||e.key==='w') move('up');
    if(e.key==='ArrowDown'||e.key==='s') move('down');
    if(e.key==='ArrowLeft'||e.key==='a') move('left');
    if(e.key==='ArrowRight'||e.key==='d') move('right');
});

// -------------------- åˆå§‹åŒ– --------------------
generateLevel();
draw();
</script>
</body>
</html>

