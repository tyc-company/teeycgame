<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>æ¨ç®±å­æ¸¸æˆğŸ“¦</title>
<style>
body{text-align:center;font-family:Arial;}
canvas{border:2px solid #333;background:#fafafa;margin-top:10px;}
button{margin:5px;padding:6px 10px;font-size:16px;}
#controls{margin-top:10px;}
</style>
</head>
<body>
<h2>æ¨ç®±å­æ¸¸æˆğŸ“¦</h2>
<div id="controls">
  <button onclick="move('up')">â¬†ï¸</button>
  <button onclick="move('left')">â¬…ï¸</button>
  <button onclick="move('down')">â¬‡ï¸</button>
  <button onclick="move('right')">â¡ï¸</button>
  <button onclick="undo()">â†©ï¸ä¸Šä¸€æ­¥</button>
  <button onclick="resetLevel()">ğŸ”„ é‡ç½®</button>
</div>
<canvas id="game" width="400" height="400"></canvas>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const size=40;
const cols=10, rows=10;

let walls=[], rocks=[], targets=[], boxes=[], player;
let history=[];
let level=1;

// -------------------- æ£€æŸ¥æ ¼å­ --------------------
function isOccupied(x,y){
    return walls.some(w=>w.x===x&&w.y===y)
        || rocks.some(r=>r.x===x&&r.y===y)
        || boxes.some(b=>b.x===x&&b.y===y && !b.locked)
        || targets.some(t=>t.x===x && t.y===y);
}
function isFree(x,y){
    if(x<0||y<0||x>=cols||y>=rows) return false;
    if(walls.some(w=>w.x===x&&w.y===y)) return false;
    if(rocks.some(r=>r.x===x&&r.y===y)) return false;
    if(boxes.some(b=>b.x===x&&b.y===y && !b.locked)) return false;
    return true;
}

// -------------------- ç”Ÿæˆå…³å¡ --------------------
function generateLevel(){
    walls=[]; rocks=[]; targets=[]; boxes=[]; history=[];
    // å¢™
    for(let i=0;i<cols;i++){ walls.push({x:i,y:0}); walls.push({x:i,y:rows-1}); }
    for(let i=0;i<rows;i++){ walls.push({x:0,y:i}); walls.push({x:cols-1,y:i}); }

    // éšæœºéšœç¢
    while(rocks.length<6){
        let x=Math.floor(Math.random()*(cols-2))+1;
        let y=Math.floor(Math.random()*(rows-2))+1;
        if(!isOccupied(x,y)) rocks.push({x,y});
    }

    // éšæœºç›®æ ‡ï¼Œä¸ä¸éšœç¢é‡å 
    while(targets.length<3){
        let x=Math.floor(Math.random()*(cols-2))+1;
        let y=Math.floor(Math.random()*(rows-2))+1;
        if(!walls.some(w=>w.x===x&&w.y===y) && !rocks.some(r=>r.x===x&&r.y===y) && !targets.some(t=>t.x===x&&t.y===y)){
            targets.push({x,y});
        }
    }

    // éšæœºæ”¾ç½®ç®±å­ï¼Œä¸åœ¨ç›®æ ‡ä¸Š
    while(boxes.length<targets.length){
        let x=Math.floor(Math.random()*(cols-2))+1;
        let y=Math.floor(Math.random()*(rows-2))+1;
        if(!isOccupied(x,y) && !targets.some(t=>t.x===x&&t.y===y)){
            boxes.push({x,y,locked:false});
        }
    }

    // åæ¨ç”Ÿæˆ
    for(let i=0;i<30;i++){
        const b = boxes[Math.floor(Math.random()*boxes.length)];
        reverseMoveBox(b);
    }

    // ç©å®¶éšæœºæ”¾ç½®åœ¨ç©ºåœ°
    let freeSpots = [];
    for(let x=1;x<cols-1;x++){
        for(let y=1;y<rows-1;y++){
            if(isFree(x,y)) freeSpots.push({x,y});
        }
    }
    if(freeSpots.length>0){
        const p = freeSpots[Math.floor(Math.random()*freeSpots.length)];
        player = {x:p.x,y:p.y};
    } else {
        player={x:1,y:1};
    }

    // æ£€æŸ¥å¯é€šå…³
    if(!isSolvable()){
        generateLevel();
    }
}

// -------------------- åæ¨ç”Ÿæˆ --------------------
function reverseMoveBox(box){
    const dirs=[{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}];
    dirs.sort(()=>Math.random()-0.5);
    for(let d of dirs){
        const playerX = box.x - d.x;
        const playerY = box.y - d.y;
        const boxX = box.x + d.x;
        const boxY = box.y + d.y;
        if(isFree(boxX,boxY) && isFree(playerX,playerY)){
            box.x=boxX; box.y=boxY;
            return true;
        }
    }
    return false;
}

// -------------------- BFSæ£€æŸ¥å¯é€šå…³ --------------------
function isSolvable(){
    let queue=[{px:player.x,py:player.y, boxStates: boxes.map(b=>({...b}))}];
    let visited = new Set();
    function stateKey(px,py,boxes){
        return px+","+py+"|"+boxes.map(b=>b.x+","+b.y).join(';');
    }
    visited.add(stateKey(player.x,player.y,boxes));
    while(queue.length>0){
        let {px,py,boxStates}=queue.shift();
        if(boxStates.every(b=>targets.some(t=>t.x===b.x && t.y===b.y))) return true;
        const moves=[{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
        for(let m of moves){
            let nx=px+m.dx, ny=py+m.dy;
            if(nx<0||ny<0||nx>=cols||ny>=rows) continue;
            if(walls.some(w=>w.x===nx&&w.y===ny) || rocks.some(r=>r.x===nx&&r.y===ny)) continue;
            let boxIdx = boxStates.findIndex(b=>b.x===nx && b.y===ny && !b.locked);
            let newBoxes=boxStates.map(b=>({...b}));
            if(boxIdx!==-1){
                let nbx=newBoxes[boxIdx].x+m.dx;
                let nby=newBoxes[boxIdx].y+m.dy;
                if(!isFree(nbx,nby)) continue;
                newBoxes[boxIdx].x=nbx;
                newBoxes[boxIdx].y=nby;
                if(targets.some(t=>t.x===nbx && t.y===nby)) newBoxes[boxIdx].locked=true;
            }
            let key=stateKey(nx,ny,newBoxes);
            if(!visited.has(key)){
                visited.add(key);
                queue.push({px:nx,py:ny,boxStates:newBoxes});
            }
        }
    }
    return false;
}

// -------------------- ç»˜åˆ¶ --------------------
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.font="32px serif";
    walls.forEach(w=>ctx.fillText('ğŸ§±', w.x*size+2,w.y*size+32));
    rocks.forEach(r=>ctx.fillText('ğŸª¨', r.x*size+2,r.y*size+32));
    targets.forEach(t=>ctx.fillText('âŒ', t.x*size+2,t.y*size+32));
    boxes.forEach(b=>ctx.fillText('ğŸ“¦', b.x*size+2,b.y*size+32));
    ctx.fillText('ğŸ¤—', player.x*size+2,player.y*size+32);
}

// -------------------- ç§»åŠ¨ --------------------
function move(dir){
    const dx=dir==='left'?-1:dir==='right'?1:0;
    const dy=dir==='up'?-1:dir==='down'?1:0;
    const newX=player.x+dx;
    const newY=player.y+dy;
    if(walls.some(w=>w.x===newX&&w.y===newY) || rocks.some(r=>r.x===newX&&r.y===newY)) return;
    let boxIndex = boxes.findIndex(b=>b.x===newX&&b.y===newY && !b.locked);
    if(boxIndex!==-1){
        let box = boxes[boxIndex];
        let nextX = box.x+dx;
        let nextY = box.y+dy;
        if(isOccupied(nextX,nextY)) return;
        history.push({player:{...player}, boxes:boxes.map(b=>({...b}))});
        box.x=nextX; box.y=nextY;
        if(targets.some(t=>t.x===nextX && t.y===nextY)) box.locked=true;
        player.x=newX; player.y=newY;
    }else{
        history.push({player:{...player}, boxes:boxes.map(b=>({...b}))});
        player.x=newX; player.y=newY;
    }
    draw();
    if(checkWin()) setTimeout(nextLevel,100);
}

// -------------------- ä¸Šä¸€æ­¥ --------------------
function undo(){
    if(history.length===0) return;
    const last = history.pop();
    player={...last.player};
    boxes = last.boxes.map(b=>({...b}));
    draw();
}

// -------------------- é‡ç½® --------------------
function resetLevel(){
    generateLevel();
    draw();
}

// -------------------- é€šå…³æ£€æµ‹ --------------------
function checkWin(){
    return boxes.every(b => targets.some(t=>t.x===b.x && t.y===b.y));
}

// -------------------- ä¸‹ä¸€å…³ --------------------
function nextLevel(){
    level++;
    alert("é€šå…³ï¼è¿›å…¥ç¬¬"+level+"å…³");
    generateLevel();
    draw();
}

// -------------------- é”®ç›˜æ§åˆ¶ --------------------
document.addEventListener("keydown",e=>{
    if(e.key==='ArrowUp'||e.key==='w') move('up');
    if(e.key==='ArrowDown'||e.key==='s') move('down');
    if(e.key==='ArrowLeft'||e.key==='a') move('left');
    if(e.key==='ArrowRight'||e.key==='d') move('right');
});

// åˆå§‹åŒ–
generateLevel();
draw();
</script>
</body>
</html>

