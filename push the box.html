<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>æ¨ç®±å­æ¸¸æˆ</title>
<style>
body{text-align:center;font-family:Arial}
canvas{border:2px solid #333;background:#fafafa;margin-top:10px;}
button{margin:5px;padding:6px 10px;font-size:16px;}
#controls{margin-top:10px;}
</style>
</head>
<body>
<h2>æ¨ç®±å­æ¸¸æˆ</h2>

<div id="controls">
  <button onclick="move('up')">â¬†ï¸</button>
  <button onclick="move('left')">â¬…ï¸</button>
  <button onclick="move('down')">â¬‡ï¸</button>
  <button onclick="move('right')">â¡ï¸</button>
  <button onclick="undo()">â†©ï¸ä¸Šä¸€æ­¥</button>
  <button onclick="resetLevel()">ğŸ”„ é‡ç½®</button>
</div>

<canvas id="game" width="400" height="400"></canvas>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const size=40;
const cols=10, rows=10;

let walls=[], rocks=[], targets=[], boxes=[], player;
let history=[];
let level=1;

// åˆå§‹åŒ–å…³å¡
function generateLevel(){
    walls = [];
    rocks = [];
    targets = [];
    boxes = [];
    history = [];

    // å¢™è¾¹
    for(let i=0;i<cols;i++){ walls.push({x:i,y:0}); walls.push({x:i,y:rows-1}); }
    for(let i=0;i<rows;i++){ walls.push({x:0,y:i}); walls.push({x:cols-1,y:i}); }

    // éšæœºéšœç¢
    while(rocks.length<6){
        let x=Math.floor(Math.random()*(cols-2))+1;
        let y=Math.floor(Math.random()*(rows-2))+1;
        if(!isOccupied(x,y)) rocks.push({x,y});
    }

    // éšæœºç›®æ ‡
    while(targets.length<3){
        let x=Math.floor(Math.random()*(cols-2))+1;
        let y=Math.floor(Math.random()*(rows-2))+1;
        if(!isOccupied(x,y)) targets.push({x,y});
    }

    // ç®±å­æ”¾åœ¨ç›®æ ‡ä¸Š
    boxes = targets.map(t=>({x:t.x,y:t.y}));

    // åå‘æ‹‰ç®±å­ç”Ÿæˆ
    for(let i=0;i<30;i++){
        const b = boxes[Math.floor(Math.random()*boxes.length)];
        reverseMoveBox(b);
    }

    // ç©å®¶æ”¾åœ¨ç©ºåœ°
    do{
        player = {x: Math.floor(Math.random()*(cols-2))+1, y: Math.floor(Math.random()*(rows-2))+1};
    }while(isOccupied(player.x,player.y));
}

// åˆ¤æ–­æ ¼å­æ˜¯å¦è¢«å ç”¨
function isOccupied(x,y){
    return walls.some(w=>w.x===x&&w.y===y)
        || rocks.some(r=>r.x===x&&r.y===y)
        || boxes.some(b=>b.x===x&&b.y===y);
}

// åˆ¤æ–­æ˜¯å¦å¯ç§»åŠ¨
function canMove(x,y){
    if(walls.some(w=>w.x===x&&w.y===y)) return false;
    if(rocks.some(r=>r.x===x&&r.y===y)) return false;
    return true;
}

// åå‘ç§»åŠ¨ç®±å­
function reverseMoveBox(box){
    const dirs=[{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}];
    dirs.sort(()=>Math.random()-0.5);
    for(let d of dirs){
        const fromX = box.x + d.x;
        const fromY = box.y + d.y;
        const pushX = box.x - d.x;
        const pushY = box.y - d.y;
        if(isFree(fromX,fromY) && isFree(pushX,pushY)){
            box.x = fromX;
            box.y = fromY;
            return true;
        }
    }
    return false;
}

function isFree(x,y){
    if(x<0||y<0||x>=cols||y>=rows) return false;
    if(walls.some(w=>w.x===x&&w.y===y)) return false;
    if(rocks.some(r=>r.x===x&&r.y===y)) return false;
    if(boxes.some(b=>b.x===x&&b.y===y)) return false;
    return true;
}

// ç»˜åˆ¶
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // å¢™
    ctx.font="32px serif";
    walls.forEach(w=>ctx.fillText('ğŸ§±', w.x*size+2,w.y*size+32));
    // éšœç¢
    rocks.forEach(r=>ctx.fillText('ğŸª¨', r.x*size+2,r.y*size+32));
    // ç›®æ ‡
    targets.forEach(t=>ctx.fillText('âŒ', t.x*size+2,t.y*size+32));
    // ç®±å­
    boxes.forEach(b=>ctx.fillText('ğŸ“¦', b.x*size+2,b.y*size+32));
    // ç©å®¶
    ctx.fillText('ğŸ¤—', player.x*size+2,player.y*size+32);
}

// ç§»åŠ¨
function move(dir){
    const dx = dir==='left'?-1:dir==='right'?1:0;
    const dy = dir==='up'?-1:dir==='down'?1:0;
    const newX = player.x + dx;
    const newY = player.y + dy;

    if(walls.some(w=>w.x===newX&&w.y===newY) || rocks.some(r=>r.x===newX&&r.y===newY)) return;

    let boxIndex = boxes.findIndex(b=>b.x===newX&&b.y===newY);
    if(boxIndex!==-1){
        let box = boxes[boxIndex];
        let nextX = box.x + dx;
        let nextY = box.y + dy;
        if(isOccupied(nextX,nextY)) return;
        // ä¿å­˜å†å²
        history.push({
            player:{...player},
            boxes:boxes.map(b=>({...b}))
        });
        box.x = nextX;
        box.y = nextY;
        player.x = newX;
        player.y = newY;
    }else{
        history.push({
            player:{...player},
            boxes:boxes.map(b=>({...b}))
        });
        player.x = newX;
        player.y = newY;
    }
    draw();
    if(checkWin()) setTimeout(nextLevel,100);
}

// ä¸Šä¸€æ­¥
function undo(){
    if(history.length===0) return;
    const last = history.pop();
    player = {...last.player};
    boxes = last.boxes.map(b=>({...b}));
    draw();
}

// é‡ç½®å…³å¡
function resetLevel(){
    generateLevel();
    draw();
}

// æ£€æŸ¥ç®±å­æ˜¯å¦åœ¨æ­»è§’
function isBoxStuck(box){
    if(targets.some(t=>t.x===box.x && t.y===box.y)) return false;
    const up = walls.concat(rocks).some(w=>w.x===box.x && w.y===box.y-1);
    const down = walls.concat(rocks).some(w=>w.x===box.x && w.y===box.y+1);
    const left = walls.concat(rocks).some(w=>w.x===box.x-1 && w.y===box.y);
    const right = walls.concat(rocks).some(w=>w.x===box.x+1 && w.y===box.y);
    if((up&&left)||(up&&right)||(down&&left)||(down&&right)) return true;
    return false;
}

// é€šå…³æ£€æŸ¥
function checkWin(){
    if(!boxes.every(b=>targets.some(t=>t.x===b.x&&t.y===b.y))) return false;
    for(let b of boxes) if(isBoxStuck(b)) return false;
    return true;
}

// ä¸‹ä¸€å…³
function nextLevel(){
    level++;
    alert("é€šå…³ï¼è¿›å…¥ç¬¬"+level+"å…³");
    generateLevel();
    draw();
}

// é”®ç›˜æ§åˆ¶
document.addEventListener("keydown",e=>{
    if(e.key==='ArrowUp'||e.key==='w') move('up');
    if(e.key==='ArrowDown'||e.key==='s') move('down');
    if(e.key==='ArrowLeft'||e.key==='a') move('left');
    if(e.key==='ArrowRight'||e.key==='d') move('right');
});

generateLevel();
draw();
</script>
</body>
</html>

